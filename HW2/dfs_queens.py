# -*- coding: utf-8 -*-
"""DFS_queens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1puD0kHn_0jLIZbtEOzNW4Atp2JNHcaYB

This is the notebook version of the code. I will use this to explain the homework.  I used parts of the code from: https://www.sanfoundry.com/python-program-solve-n-queen-problem-without-recursion/

As we did in class, we will represent the size as a one-dimensional array where each position in the arrray is the n'th queen's column value. So if the array is: [1, 3, 0, 2], then the first queen is in position 1 (from 0--3), the second queen is in position 3 (the last column), the third queen is in the first column and the last queen is the in the second position.
"""
from ast import main
from functools import total_ordering
from itertools import count
from mimetypes import init
import copy
from random import *
from tkinter.ttk import *
from tokenize import Number
from turtle import st
from typing import Counter
columns = [] #columns is the locations for each of the queens
# columns[r] is a number c if a queen is placed at row r and column c.
size = 8
import random #hint -- you will need this for the following code: column=random.randrange(0,size)
minimum = 10000000
maximum = 0
average = 0

"""Let's setup one iteration of the British Museum algorithm-- we'll put down 4 queens randomly."""

def place_n_queens(size):
    columns.clear()
    row = 0
    while row < size:
        column=random.randrange(0,size)
        columns.append(column)
        row+=1

# place_n_queens(size)

"""Now, we can print the result with a simple loop:"""

def display():
    for row in range(len(columns)):
        for column in range(size):
            if column == columns[row]:
                print('â™›', end=' ')
            else:
                print(' .', end=' ')
        print()

# place_n_queens(size)
# display()
# print(columns)

"""This of course is not necessary legal, so we'll write a simple DFS search with backtracking:"""
def solve_queen(size):
    columns.clear()
    number_of_moves = 0 #where do I change this so it counts the number of Queen moves?
    number_of_iterations = 0  
    row = 0
    column = 0
    # iterate over rows of size
    while True:
        #place queen in next row
        ''''print(columns)
        print("I have ", row, " number of queens put down")
        display()
        print(number_of_moves)'''
        while column < size:
            number_of_iterations+=1
            if next_row_is_safe(column):
                place_in_next_row(column)
                row += 1
                column = 0
                break
            else:
                column += 1
        # if I could not find an open column or if size is full
        if (column == size or row == size):
            number_of_iterations+=1
            # if size is full, we have a solution
            if row == size:
                print("I did it! Here is my solution")
                display()
                #print(number_of_moves)
                return number_of_iterations, number_of_moves
            # I couldn't find a solution so I now backtrack
            prev_column = remove_in_current_row()
            if (prev_column == -1): #I backtracked past column 1
                print("There are no solutions")
                #print(number_of_moves)
                return number_of_iterations, number_of_moves
            # try previous row again
            row -= 1
            # start checking at column = (1 + value of column in previous row)
            column = 1 + prev_column

"""This code is nice, but it uses three functions:
1. place_in_next_row
2. remove_in_current_row
3. next_row_is_safe
That we now have to define
"""

def place_in_next_row(column):
    columns.append(column)
 
def remove_in_current_row():
    if len(columns) > 0:
        return columns.pop()
    return -1

def next_row_is_safe(column):
    row = len(columns) 
    # check column
    for queen_column in columns:
        if column == queen_column:
            return False
 
    # check diagonal
    for queen_row, queen_column in enumerate(columns):
        if queen_column - queen_row == column - row:
            return False
 
    # check other diagonal
    for queen_row, queen_column in enumerate(columns):
        if ((size - queen_column) - queen_row
            == (size - column) - row):
            return False
    return True

#size = int(input('Enter n: '))
# num_iterations=0
# number_moves = 0
# #for i in range(0, 100):
# #    columns = [] #columns is the locations for each of the queens
# num_iterations, number_moves=solve_queen(size)
# print(num_iterations)
# print(number_moves)
# print(columns)

"""Now what?  Can you implement the British Museum Algorithm?  How many iterations did it take to solve the 4 queens problem?  How many did it take to solve the 8 queens (if at all)?"""

def BritishMuseumAlgorithm(size):
    counter = 1
    place_n_queens(size)
    while(not valid_size(size)):
        counter +=1
        place_n_queens(size)
    return counter

def valid_size(size):
    mapping = set()
    for col in columns:
        mapping.add(col)
    if len(mapping) != size:
        return False
    for x in range(size):
        for col in range(x + 1, size):
            if abs(x - col) == abs(columns[x] - columns[col]):
                return False
    return True

#keeps track of number of iterations (every time we reset the board)
numberOfIter = 1
def hillClimbing(size):
    global numberOfIter
    #place n queens
    place_n_queens(size) 
    #might need range here
    lowestAttackLocation = 10000000
    #this keeps track of the number of moves
    counter = 0
    #there were size amount of queens placed already
    counter += size
    arr=[]
    # a List of the best possible moves on the board
    bestMoves =[]
    # run the while loop until you get to a solution
    while True:  
        #go through each column and calculate the if you moved a queen to a given spot
        #how many times would that queen be attacked
        for i in range(size):
                currentColumn = i
                #make sure to no count the amount of attack of a current peice.
                currentLocationOfPeice = columns[i]
                lis = []
                for x in range(size):
                    #if we are a location in a row that is not of the current peice, calulate how many times this peice would be attakce
                    if x != currentLocationOfPeice:
                        #pass in the Location of a peice in the row, the row, and the column of a position
                        # it reutrns the [amount of attack on that positon, row, column and previous spot]
                        attackandLocation = getAmountofConflicts(currentLocationOfPeice,x,currentColumn)
                        lis.append(attackandLocation[0])
                        #if this is the best spot wipe the previouse best spots and add this
                        if attackandLocation[0] < lowestAttackLocation:
                            lowestAttackLocation = attackandLocation[0]
                            bestMoves.clear()
                            bestMoves.append(attackandLocation)
                        #if it is equally as good as other spots, add thit to the list of spots
                        elif attackandLocation[0] == lowestAttackLocation:
                            bestMoves.append(attackandLocation)
                            
                    else:
                        #this is for testing
                        lis.append("X")
                arr.append(lis)
        lowestAttackLocation = 10000000
        #Once you have calculated all of the spots, pick a random spot in the list of best spots to move
        x = random.randint(0,len(bestMoves)-1)
        #move to that spot
        moveLocation(bestMoves[x])
        bestMoves.clear()
        #count a move being made
        counter+=1
        if valid_size(size):
            return counter 
        elif counter == 200:
            #if you have made ove 200 moves, scratch it and start again
            numberOfIter+=1
            return hillClimbing(size) + counter

def getAmountofConflicts(moveFrom,moveTo,currentColumn):
    totalConflicts = 0
            #go through each column of the current size and see how many conflicts there are if I move the peice to location i
    for col in columns:
        if(col == moveTo):
            totalConflicts += 1
    #try and see if I move to ne location how many attack on the diagnals will there be? This is not going to work

    columns[currentColumn] = moveTo

    # # check down right
    for col in range(currentColumn+1,size):
        if moveTo + col - currentColumn == columns[col]:
            totalConflicts += 1
        

    # # #check down left
    for col in range(currentColumn+1,size):
        if moveTo - col + currentColumn == columns[col]:
            totalConflicts += 1

    # #check up left
    for col in reversed(range(currentColumn)):
        if moveTo + col - currentColumn == columns[col]:
            totalConflicts += 1

    # #check up right
    for col in reversed(range(currentColumn)):
        if moveTo - col + currentColumn == columns[col]:
            totalConflicts += 1

    columns[currentColumn] = moveFrom
    toReturn = []
    toReturn.append(totalConflicts)
    toReturn.append(moveFrom)
    toReturn.append(moveTo) 
    toReturn.append(currentColumn) 
    return toReturn

def moveLocation(toMove):
    columns[toMove[3]] = toMove[2]

countCST = 0
class ChessBoard():

    def __init__(self,size,rowUpTo):
        #boolean array of places that you can move
        self.board = [[True for j in range(size)] for i in range(size)]
        #all eligble spots in the row (I pick a random spot to speed up runtime)
        self.eligibleSpots = {}

        self.rowUpTo = rowUpTo
        self.move = 0
        self.queens = {}
        for i in range(size):
            self.eligibleSpots[i] = [j for j in range(size)]
    
    def placeQueen(self,row,column):
        self.queens[row] = column

    def removeEligbleSpots(self,row,removeSpot):
        openSpots = self.eligibleSpots[row]
        if removeSpot in openSpots: 
            openSpots.remove(removeSpot)
    
    def getOpenSpot(self,row):
        return self.eligibleSpots[row]

    def disAllowSpot(self,column, row):
        self.board[column][row] = False
    
    def saveMoveRow(self,column):
        self.move = column

    def prevMove(self):
        return self.move

    def printBoard(self):
        for row in self.board:
            print(row)

def SimpleCST(size):
    global totalCounter, countCST
    stack = []
    #create a board and thne create a second board that we can make a move on
    board = ChessBoard(size,0)
    board2 = copy.deepcopy(board)
    stack.append(board) 
    #pick a random open spot
    openSpots = board2.getOpenSpot(board2.rowUpTo)
    ColumnToPlaceQueen = random.choice(openSpots)
    #place a queen there 
    board2.placeQueen(board2.rowUpTo,ColumnToPlaceQueen)
    countCST+=1
    #remove all of the spots that are no longer available
    setFalse(board2.rowUpTo,ColumnToPlaceQueen,board2)
    stack.append(board2)
    #check to see if stack is empty
    while len(stack):
        board = stack.pop()
        board2 = copy.deepcopy(board)
        stack.append(board)
        openSpots = board2.getOpenSpot(board2.rowUpTo)
        # if there are no longer spots, remove the previous 2 moves. 
        # The first NOT made more recently mark off the new spot that we no we can not go in the future
        if not len(openSpots):
            board1 = stack.pop()
            board2 = stack.pop()
            board2.disAllowSpot(board2.rowUpTo,board1.prevMove())
            board2.removeEligbleSpots(board2.rowUpTo,board1.prevMove())
            stack.append(board2)
        else:
            #if there are spots available, keep trying to put queens down

            #pick a random available location
            ColumnToPlaceQueen = random.choice(openSpots)
            board2.saveMoveRow(ColumnToPlaceQueen)
            board2.placeQueen(board2.rowUpTo,ColumnToPlaceQueen)
            countCST+=1

            #this method sets all of the spots no longer available
            setFalse(board2.rowUpTo,ColumnToPlaceQueen,board2)
            if board2.rowUpTo == size:
                break
            stack.append(board2)
        #if the board is valid break
    return board2.queens
    
def setFalse(row,column,board):
    board.disAllowSpot(row,column)
    for i in range(1,size-board.rowUpTo):
        board.disAllowSpot(row+i,column)
        board.removeEligbleSpots(row+i,column)
        if row+i == size-1:
            break
    for j in range(1,size-board.rowUpTo):
        #upDiagnal
        if column - j >= 0:
            board.disAllowSpot(board.rowUpTo+j,column-j)
            board.removeEligbleSpots(board.rowUpTo+j,column-j)
        if column + j <= size-1:
            board.disAllowSpot(board.rowUpTo+j,column+j)
            board.removeEligbleSpots(board.rowUpTo+j,column+j)
    board.rowUpTo +=1
    # board.printBoard()
    return



maxIter = 0
MinIter =1000
averageIter = 0
def main():
    global columns,maximum,minimum,countCST,maxIter,MinIter,averageIter, numberOfIter 
    # global height

    
    counter = 0
    for i in range(0,100):
        #backtracking
        # totalMoves,totalIter = solve_queen(8)
        # if totalMoves > maximum:
        #     maximum = totalMoves
        # elif totalMoves < minimum:
        #     minimum = totalMoves
        # if totalIter > maxIter:
        #     maxIter = totalIter
        # elif totalIter < MinIter:
        #     MinIter = totalIter
        # counter += totalMoves
        # averageIter += totalIter


        #hillclimbing
        # answer =  hillClimbing(8)
        # counter += answer
        # if answer > maximum:
        #     maximum = answer
        # elif answer < minimum:
        #     minimum = answer
        # if numberOfIter > maxIter:
        #     maxIter = numberOfIter
        # elif numberOfIter < MinIter:
        #     MinIter = numberOfIter
        # averageIter += numberOfIter
        # numberOfIter = 1



        #ForwardChecking
        answer = SimpleCST(size)
        lis =[]
        for key in answer:
            lis.append(answer[key])
        columns = lis
        counter+=countCST
        if countCST > maximum:
            maximum = countCST
        elif countCST < minimum:
            minimum = countCST
        countCST = 0
        MinIter = counter/100
        maxIter = counter/100
        averageIter = counter
    print('minimum moves:' +  str(minimum))
    print("maximum moves: " + str(maximum))
    print('average moves: ' + str(counter/100))
    print('minimum iterations:' +  str(MinIter))
    print("maximum iterations: " + str(maxIter))
    print('average iterations: ' + str(averageIter/100))
    # print(countCST)
    # print(countCST/100) 
main()

"""
British Meuseum:

    British Meuseum Algorithm for 8X8 board total moves ran 100X:
    Did not finish

Backtracking:

    minimum moves:982
    maximum moves: 982
    average moves: 982.0


Hill Climbing:
    
    Hill Climbing Algorithm for 8X8 board total moves ran 100X:
    minimum moves:10
    maximum moves: 826
    average moves: 188.18
    minimum iterations:1
    maximum iterations: 5
    average iterations: 1.82

CSP/Forward Checking

    CSP for 8X8 board total moves ran 100X:
    minimum moves:8
    maximum moves: 116
    average moves: 30.34
    minimum iterations:30.34
    maximum iterations: 30.34
    average iterations: 30.34

"""
